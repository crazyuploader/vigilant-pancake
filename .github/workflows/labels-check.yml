name: Validate Docs Metadata

on:
  pull_request:
    paths:
      - "data/docs/**.mdx"

concurrency:
  group: validate-docs-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  validate-docs-metadata:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed documentation files
        id: changed-files
        run: |
          # Get the base and head commits
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          
          echo "Comparing $BASE_SHA...$HEAD_SHA"
          
          # Get changed files matching the pattern
          CHANGED_FILES=$(git diff --name-only --diff-filter=ACMR "$BASE_SHA...$HEAD_SHA" | grep -E '^data/docs/.*\.mdx$' || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "any_changed=false" >> $GITHUB_OUTPUT
            echo "No documentation files changed"
          else
            echo "any_changed=true" >> $GITHUB_OUTPUT
            # Convert newlines to spaces for easier processing
            FILES_SPACE_SEPARATED=$(echo "$CHANGED_FILES" | tr '\n' ' ' | sed 's/ $//')
            echo "all_changed_files=$FILES_SPACE_SEPARATED" >> $GITHUB_OUTPUT
            echo "Changed files: $FILES_SPACE_SEPARATED"
          fi

      - name: Validate documentation metadata
        if: steps.changed-files.outputs.any_changed == 'true'
        id: validate
        run: |
          set -e

          echo "Checking documentation files for required metadata..."

          INVALID_FILES=()
          ALL_VALID=true
          CURRENT_DATE=$(date +%Y-%m-%d)

          # Convert space-separated files to array
          IFS=' ' read -ra CHANGED_FILES <<< "${{ steps.changed-files.outputs.all_changed_files }}"

          for file in "${CHANGED_FILES[@]}"; do
            [[ -z "$file" ]] && continue

            echo "Checking: $file"

            # Check file exists
            if [ ! -f "$file" ]; then
              echo "❌ $file: file not found"
              INVALID_FILES+=("$file|file not found")
              ALL_VALID=false
              continue
            fi

            # Extract frontmatter between first two --- markers
            if ! FRONTMATTER=$(awk '/^---$/{if(++count==2) exit} count==1 && !/^---$/ {print}' "$file" 2>/dev/null); then
              echo "❌ $file: cannot read file"
              INVALID_FILES+=("$file|cannot read file")
              ALL_VALID=false
              continue
            fi

            ERRORS=()

            # Validate tags field
            if ! echo "$FRONTMATTER" | grep -q "^tags:"; then
              ERRORS+=("missing tags")
            elif ! echo "$FRONTMATTER" | grep -q "^tags:.*\["; then
              ERRORS+=("tags must be an array")
            elif echo "$FRONTMATTER" | grep -qE "^tags:.*\[\s*\]"; then
              ERRORS+=("tags array cannot be empty")
            fi

            # Validate date field
            if ! echo "$FRONTMATTER" | grep -q "^date:"; then
              ERRORS+=("missing date")
            else
              DOC_DATE=$(echo "$FRONTMATTER" | grep "^date:" | sed 's/date:\s*//' | tr -d ' ')
              if ! echo "$DOC_DATE" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
                ERRORS+=("invalid date format - use YYYY-MM-DD")
              elif ! date -d "$DOC_DATE" >/dev/null 2>&1; then
                ERRORS+=("invalid date value")
              elif [[ "$DOC_DATE" > "$CURRENT_DATE" ]]; then
                ERRORS+=("date cannot be in the future")
              fi
            fi

            # Validate title field
            if ! echo "$FRONTMATTER" | grep -q "^title:"; then
              ERRORS+=("missing title")
            fi

            if [ ${#ERRORS[@]} -gt 0 ]; then
              ERROR_MSG=$(IFS="; "; echo "${ERRORS[*]}")
              echo "❌ $file: $ERROR_MSG"
              INVALID_FILES+=("$file|$ERROR_MSG")
              ALL_VALID=false
            else
              echo "✅ $file has valid metadata"
            fi
          done

          # Set outputs
          echo "current_date=$CURRENT_DATE" >> $GITHUB_OUTPUT

          if [ "$ALL_VALID" = false ]; then
            echo "validation_failed=true" >> $GITHUB_OUTPUT

            {
              echo "invalid_files<<EOF"
              printf '%s\n' "${INVALID_FILES[@]}"
              echo "EOF"
            } >> $GITHUB_OUTPUT

            exit 1
          else
            echo "validation_failed=false" >> $GITHUB_OUTPUT
          fi

      - name: Update PR with validation results
        if: always() && steps.changed-files.outputs.any_changed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const validationFailed = '${{ steps.validate.outputs.validation_failed }}' === 'true';
            const currentDate = '${{ steps.validate.outputs.current_date }}';

            // Find existing bot comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('## 📄 Documentation Metadata Validation')
            );

            if (validationFailed) {
              // Add blocking label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['docs-metadata-missing']
              });

              // Parse and format invalid files
              const invalidFilesRaw = `${{ steps.validate.outputs.invalid_files }}`;
              const fileLines = invalidFilesRaw.trim().split('\n').filter(Boolean);

              const linkedFiles = fileLines.map(line => {
                const [filePath, reason] = line.split('|');
                const fileUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${context.payload.pull_request.head.sha}/${filePath}`;
                return `- [${filePath}](${fileUrl}) — ${reason}`;
              }).join('\n');

              const body = `## 📄 Documentation Metadata Validation

              ❌ **Validation Failed**

              The following documentation files are missing required metadata:

              ${linkedFiles}

              ### Required Fields
              - \`tags: []\` — Array of tags (e.g., \`["SigNoz Cloud", "Self-Host"]\`)
              - \`date:\` — Date in YYYY-MM-DD format
              - \`title:\` — Non-empty title field

              ### Example
              \`\`\`yaml
              ---
              title: My Documentation Page
              date: ${currentDate}
              tags: ["SigNoz Cloud", "Self-Host"]
              ---
              \`\`\`
              Please add the required metadata to these docs to proceed with this PR.`;

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: body
                });
              }
            } else {
              // Remove label on success
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: 'docs-metadata-missing'
                });
              } catch (error) {
                console.log('Label does not exist or already removed');
              }

              // Update comment on success
              if (botComment) {
                const successBody = `## 📄 Documentation Metadata Validation

                ✅ **All Valid**

                All documentation files have the required metadata fields.`;

                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: successBody
                });
              }
            }

      - name: Generate summary
        if: always() && steps.changed-files.outputs.any_changed == 'true'
        run: |
          if [ "${{ steps.validate.outputs.validation_failed }}" == "true" ]; then
            echo "## ❌ Validation Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following documentation files have metadata issues:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            while IFS='|' read -r file reason; do
              echo "- **$file**: $reason" >> $GITHUB_STEP_SUMMARY
            done <<< "${{ steps.validate.outputs.invalid_files }}"
          else
            echo "## ✅ All Documentation Files Valid" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All changed documentation files have the required metadata fields." >> $GITHUB_STEP_SUMMARY
          fi
